================================== 배운점 =====================================

1. 자료구조개론때 파이썬을 통해서 배웠던 class와 변수, 메소드 따위를 C++에서 다시 배우니까 좀 더 구체
적으로 습득할 수 있게 됨. 예를 들어서 class 외부에서 선언된 PhysicalAddress는 FTL 함수를 정의할 때
굳이 앞에 FTL:: 을 붙일 필요가 없음. 이 이유는 PhysicalAddress를 좀 더 보편적으로 상용하기 위해서임을
알게 됨. 

2. NandFlash을 활용하는 FTL의 방식에 대해 이해하게 됨. 일단 FTL의 데이터 저장 방식은, OS에서 요구한
논리 주소와 관계없이 피지컬 주소를 하나씩 늘려 나가는 것! 무작정 늘려나가다가 더 이상 쓸 곳이 없으면 
garbage 처리 => 이것이 왜 효율적인가? 에 대해선 생각해볼 필요가 있음

3. 헤더 파일을 보면서 draw.io를 작업하는게 훨씬 빠름. 이것도 헤더 파일의 장점이라고 볼 수 있을까.

4. draw.io의 용이함? 그러니까 const int NUM_LOGICAL_PAGES = NUM_BLOCKS * PAGES_PER_BLOCK * 0.75;
이런 구문을 보면 block이나 page의 형상이 헷갈리기 마련인데, draw.io를 통해 순식간에 전체적인 체계를 복
습함으로써 이해가 빨라짐. 이것도 실무에서 좋은 효과를 거둘 수 있지 않을까 생각. 직사각형들과 텍스트, 화살표
만 있다면 글로 정리하는 것보다 훨씬 이해가 빠름. 또 '내가 나만의 아키텍쳐를 만들었기 때문에' 더 친숙하고
습득이 빠르지 않나 생각.

5. 복잡한 코드 => 직접 파일들을 오가면서 익히는 것보다 제미나이한테 물어보는게 효과적. 이것은 확실히 요즘
AI가 엔지니어보다 잘하는 것 (요약)이고 필수 수단이 될 것이라 생각. 즉, 엔지니어는 이제 코드를 위에서부터 아
래로 다 읽어나가기 보다는, '여기 이게 왜 있는 것이지? 이 모듈이 하는 역할은 궁극적으로 그래서 무엇이지?'를
재빨리 캐치하는 역량이 중요할 것 같음.

6. 현실과 유사하도록 제약을 설정함으로써 시뮬레이션을 통해 최적의 알고리즘을 찾을 수 있음. 그러나 이러한 과
정에서 반대되는 결과도 존재. 예를 들어 HOT/COLD 데이터의 분포가 10% / 90%인 상황을 구현하기 위해, main.cpp
의 FTL은 쓰기의 90%를 10%의 lpn 논리 주소에 부여하도록 했지만, 오히려 예상과 반대로 WAF의 값이 현저하게 줄어
드는 결과가 나옴. 이는 역설적이게도 FTL에게 Garbage Collect를 할 수 있는 좋은 환경을 만들어준 것. 이러한  의
도치 않은 상황을 피하기 위해 엔지니어가 할 일은, 코드의 환경을 더욱 엄격하게, 즉 현실과 비슷하도록 만드는 것.

(제미나이의 말로는 get_new_page가 너무나 이상적이라고 함)

7. 제미나이의 실수: hot/cold 으로 active 블록을 나눈 뒤 희생될 victim block을 선택하여 hot/cold page의 개수를
전부 세는 로직을 짰었는데, 사실상 둘 중 하나는 0의 값을 가질 수밖에 없음. 나는 이것을 직접 확인하기 위해 디버깅을
위한 출력 함수를 만듬 (실시간으로 Garbage Collect가 실행될 때마다 출력하는 함수). 내가 옳았다! => 수정 결과 WAF
대폭 감소. 13.2에서 2 주변으로 하락함. 이는 GC 작업을 폭발적으로 일으키는 연쇄 반응이라고 함. 

8. 스마트 병합과 관련하여 => 아무리 생각해도 current page가 1이 아님에도 불구하고 victim block 찾기가 수행될 상
황이 불가능한 것 같은데... 제미나이는 그것을 가정하고 코드를 서술함. 인공지능이 아직 완전히 발달하지 못한 것인가? 상
황을 파악하고 코드가 어떻게 동작하는지는 아직 사람이 해야할 일 같다... 현재 코드의 상황을 파악하고, 그 메커니즘 사이
에서 최적의 방안을 찾아내는 것. 그것이 사람이 해야할 일?